package com.vehiclebooking.backend.service.impl;

import com.vehiclebooking.backend.dto.AuthRequest;
import com.vehiclebooking.backend.dto.SaveOtpRequest;
import com.vehiclebooking.backend.dto.VerifyOtpRequest;
import com.vehiclebooking.backend.dto.DriverRegistrationRequest;
import com.vehiclebooking.backend.exception.ResourceNotFoundException;
import com.vehiclebooking.backend.model.Otp;
import com.vehiclebooking.backend.model.User;
import com.vehiclebooking.backend.model.enums.Role;
import com.vehiclebooking.backend.repository.OtpRepository;
import com.vehiclebooking.backend.repository.UserRepository;
import com.vehiclebooking.backend.service.AuthService;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class AuthServiceImpl implements AuthService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final OtpRepository otpRepository;

    @Override
    public String sendOtp(AuthRequest request) {
        // Firebase handles sending OTP on frontend
        // This endpoint is kept for backward compatibility
        return "OTP will be sent via Firebase";
    }

    @Override
    public String saveFirebaseOtp(SaveOtpRequest request) {
        // Save the OTP generated by Firebase to our database
        // OTP expires in 5 minutes
        Otp otp = Otp.builder()
                .phoneNumber(request.getPhoneNumber())
                .otp(request.getOtp())
                .createdAt(LocalDateTime.now())
                .expiresAt(LocalDateTime.now().plusMinutes(5))
                .isUsed(false)
                .build();

        otpRepository.save(otp);
        return "OTP saved successfully";
    }

    @Override
    public User verifyOtp(VerifyOtpRequest request) {
        String phoneNumber = request.getPhoneNumber();
        String otpInput = request.getOtp();

        // Find the latest unused OTP for this phone number
        Optional<Otp> otpOpt = otpRepository.findTopByPhoneNumberAndIsUsedFalseOrderByCreatedAtDesc(phoneNumber);

        if (!otpOpt.isPresent()) {
            throw new RuntimeException("No OTP found for this phone number. Please request a new OTP.");
        }

        Otp otp = otpOpt.get();

        // Check if OTP has expired
        if (LocalDateTime.now().isAfter(otp.getExpiresAt())) {
            throw new RuntimeException("OTP has expired. Please request a new OTP.");
        }

        // Verify OTP
        if (!otp.getOtp().equals(otpInput)) {
            throw new RuntimeException("Invalid OTP. Please try again.");
        }

        // Mark OTP as used
        otp.setUsed(true);
        otp.setUsedAt(LocalDateTime.now());
        otpRepository.save(otp);

        // Find or create user
        Optional<User> userOpt = userRepository.findByPhoneNumber(phoneNumber);
        if (userOpt.isPresent()) {
            return userOpt.get();
        } else {
            // Register new user
            User newUser = User.builder()
                    .phoneNumber(phoneNumber)
                    .role(Role.CUSTOMER) // Default
                    .isVerified(true)
                    .build();
            return userRepository.save(newUser);
        }
    }

    @Override
    public User loginWithPassword(AuthRequest request) {
        User user = userRepository.findByPhoneNumber(request.getPhoneNumber())
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        if (user.getPassword() == null || !passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            throw new RuntimeException("Invalid credentials");
        }

        return user;
    }

    @Override
    public User register(AuthRequest request) {
        if (userRepository.findByPhoneNumber(request.getPhoneNumber()).isPresent()) {
            throw new RuntimeException("User already exists with this phone number");
        }

        User newUser = User.builder()
                .phoneNumber(request.getPhoneNumber())
                .fullName(request.getFullName())
                .password(passwordEncoder.encode(request.getPassword()))
                .role(request.getRole() != null ? request.getRole() : Role.CUSTOMER)
                .isVerified(true) // For now auto verify
                .build();

        return userRepository.save(newUser);
    }

    @Override
    public User googleLogin(String idToken) {
        try {
            // Verify the Google ID token
            // Note: In production, you should verify the token with Google
            // For now, we'll decode it manually (this is simplified for MVP)

            // Split the JWT token to get the payload
            String[] parts = idToken.split("\\.");
            if (parts.length != 3) {
                throw new RuntimeException("Invalid Google ID token format");
            }

            // Decode the payload (base64)
            String payload = new String(java.util.Base64.getUrlDecoder().decode(parts[1]));

            // Parse JSON to extract email and name
            // In production, use a proper JSON library or Google's ID token verifier
            String email = extractJsonValue(payload, "email");
            String name = extractJsonValue(payload, "name");
            String googleId = extractJsonValue(payload, "sub");

            if (email == null || googleId == null) {
                throw new RuntimeException("Invalid Google token - missing required fields");
            }

            // Find user by email or Google ID
            Optional<User> userOpt = userRepository.findByEmail(email);

            if (userOpt.isPresent()) {
                // Existing user - update if needed
                User existingUser = userOpt.get();
                if (existingUser.getFullName() == null && name != null) {
                    existingUser.setFullName(name);
                    return userRepository.save(existingUser);
                }
                return existingUser;
            } else {
                // New user - create account
                User newUser = User.builder()
                        .email(email)
                        .fullName(name)
                        .role(Role.CUSTOMER)
                        .isVerified(true)
                        .build();
                return userRepository.save(newUser);
            }
        } catch (Exception e) {
            throw new RuntimeException("Google authentication failed: " + e.getMessage());
        }
    }

    @Override
    public User updatePhoneNumber(Long userId, String phoneNumber) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        // Validate phone number format (10 digits)
        if (phoneNumber == null || !phoneNumber.matches("^[0-9]{10}$")) {
            throw new RuntimeException("Invalid phone number format. Must be 10 digits.");
        }

        // Check if phone number already exists for another user
        Optional<User> existingUser = userRepository.findByPhoneNumber(phoneNumber);
        if (existingUser.isPresent() && !existingUser.get().getId().equals(userId)) {
            throw new RuntimeException("Phone number already registered to another user");
        }

        user.setPhoneNumber(phoneNumber);
        return userRepository.save(user);
    }

    @Override
    public User registerDriver(DriverRegistrationRequest request) {
        try {
            // Verify the Google ID token (same logic as googleLogin)
            String[] parts = request.getIdToken().split("\\.");
            if (parts.length != 3) {
                throw new RuntimeException("Invalid Google ID token format");
            }

            // Decode the payload
            String payload = new String(java.util.Base64.getUrlDecoder().decode(parts[1]));

            // Extract email and name
            String email = extractJsonValue(payload, "email");
            String name = extractJsonValue(payload, "name");
            String googleId = extractJsonValue(payload, "sub");

            if (email == null || googleId == null) {
                throw new RuntimeException("Invalid Google token - missing required fields");
            }

            // Check if user already exists
            Optional<User> existingUser = userRepository.findByEmail(email);
            if (existingUser.isPresent()) {
                throw new RuntimeException("User already registered with this email");
            }

            // Create driver user
            User driver = User.builder()
                    .email(email)
                    .fullName(name)
                    .phoneNumber(null) // Optional, can add via PhoneNumberModal later
                    .role(Role.DRIVER)
                    .licenseNumber(request.getLicenseNumber())
                    .documentUrl(request.getLicenseFrontUrl()) // Front photo
                    .licenseBackUrl(request.getLicenseBackUrl()) // Back photo
                    .isVerified(false) // Needs admin verification
                    .build();

            return userRepository.save(driver);
        } catch (Exception e) {
            throw new RuntimeException("Driver registration failed: " + e.getMessage());
        }
    }

    @Override
    public User upgradeToDriver(DriverRegistrationRequest request) {
        if (request.getUserId() == null) {
            throw new RuntimeException("User ID is required");
        }

        User user = userRepository.findById(request.getUserId())
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        // If user is already a verified driver, just return
        if (user.getRole() == Role.DRIVER && user.isVerified()) {
            return user;
        }

        user.setRole(Role.DRIVER);
        user.setLicenseNumber(request.getLicenseNumber());
        user.setDocumentUrl(request.getLicenseFrontUrl());
        user.setLicenseBackUrl(request.getLicenseBackUrl());
        user.setVerified(false); // Requires admin approval

        return userRepository.save(user);
    }

    @Override
    public User getUserById(Long userId) {
        return userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with ID: " + userId));
    }

    // Helper method to extract JSON values
    private String extractJsonValue(String json, String key) {
        String searchKey = "\"" + key + "\":\"";
        int startIndex = json.indexOf(searchKey);
        if (startIndex == -1) {
            return null;
        }
        startIndex += searchKey.length();
        int endIndex = json.indexOf("\"", startIndex);
        if (endIndex == -1) {
            return null;
        }
        return json.substring(startIndex, endIndex);
    }
}
